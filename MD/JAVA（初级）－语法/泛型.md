# 泛型

> 将明确类型的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型 
## 描述
 1. Java泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常
  2. 参数化类型
     - 把类型当作是参数传递
     - <数据类型>只能是引用类型
3. 相关术语
   - `List<E> `    E称为类型参数变量
   - `List<Student>`    Student称为实际类型参数

## 泛型类  

>  把泛型定义在类上，在使用该类时明确泛型具体类型
> 类上声明的泛型只对非静态成员有效(静态成员的加载早于其他成员)

- 定义泛型类ObjectTool
```java
     //泛型类 ObjectTool
     public class ObjectTool<T> {
         private T obj;
 
         public ObjectTool() {}
 
         public ObjectTool(T obj) {
             this.obj = obj;
         }
         public T getObj() {
             return obj;
         }
         public void setObj(T obj) {
             this.obj = obj;
         }
     }
```
 - 使用ObjectTool
```java
     //创建对象并指定元素类型,此处ObjectTool只能处理String类型的
     ObjectTool<String> tool = new ObjectTool<>();
     tool.setObj("string");
     String s = tool.getObj();

	 tool.setObj(new Student()); //编译错误
```

## 泛型方法  

>  若不关心类的其他属性、方法，只需要在某一个方法上使用泛型，便不需要在整个类上定义泛型

- 在ObjectTool添加show方法
```java
     public static <T> void show(T t) {
             System.out.println(t);
     }	
```
 - 调用该方法
```java
     ObjectTool.show("1111");//字符串
     ObjectTool.show(1111);//整型
```

## 子类继承、实现泛型类、泛型接口

- 子类明确泛型类的类型参数变量
```java
    public class StringTool extends ObjectTool<String> {
        private String test(String str){}
    }
```
- 子类不明确泛型类的类型参数变量
```java
    public class TTool<T> extends ObjectTool<T> {
         private T test(T str){}
    }
```

## 通配符? 在不确定元素类型时使用
```java
   ObjectTool<String> strTool;
   ObjectTool<?> tool;
   strTool = new ObjectTool<String>();//right
   strTool = new ObjectTool<Integer>();//wrong

   tool = new ObjectTool<String>();//right
   tool = new ObjectTool<Integer>();//right  
    
   //设定通配符上下限
   //上限 装载Number及其子类
   List<? extends Number> list
   //下限 装载Integer及其父类
   List<? super Integer> list
```

## pesc原则
 - 设定三个类
```java
    class Food {}
    class Fruit extends Food {}
    class Apple extends Fruit {}
```
- 如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；
```java
    List<? extends Food> list = new ArrayList<>();
    list = new ArrayList<Fruit>();//right
    list.add(new Fruit());//wrong
```
若允许写入，取出Fruit是应为Food类型，需要使用Fruit的方法时需强转，失去泛型意义
- 如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；
```java
    List<? super Fruit> list = new ArrayList<>();
    list = new ArrayList<Fruit>();//right
    list = new ArrayList<Apple>();//wrong
    list.add(new Food());//wrong
    list.add(new Apple());//right
```
添加fruit子类可以被视作fruit，所以能添加成功；添加其父类是，不知其具体父类，阻止写入
- 如果既要存又要取，那么就不要使用任何通配符。
## 类型擦除
> JAVA的泛型是伪泛型，在编译期间，所有的泛型信息都会被擦掉